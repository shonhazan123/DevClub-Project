{"ast":null,"code":"'use strict';\n/* istanbul ignore next - affordance for node v8 */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\shonh\\\\Desktop\\\\VisualCode\\\\WebDevClub\\\\RecruitmentDay\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\shonh\\\\Desktop\\\\VisualCode\\\\WebDevClub\\\\RecruitmentDay\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nif (!String.prototype.trimEnd) {\n  String.prototype.trimEnd = function () {\n    return this.replace(/[\\n\\r\\s\\t]+$/, '');\n  };\n}\n\nvar escapeStringRegexp = require('escape-string-regexp');\n\nvar natives = [].concat(require('module').builtinModules, 'bootstrap_node', 'node').map(function (n) {\n  return new RegExp(\"(?:\\\\((?:node:)?\".concat(n, \"(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?\").concat(n, \"(?:\\\\.js)?:\\\\d+:\\\\d+$)\"));\n});\nnatives.push(/\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\n\nvar StackUtils = /*#__PURE__*/function () {\n  function StackUtils(opts) {\n    _classCallCheck(this, StackUtils);\n\n    opts = Object.assign({}, {\n      ignoredPackages: []\n    }, opts);\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = process.cwd();\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  _createClass(StackUtils, [{\n    key: \"clean\",\n    value: function clean(stack, indent) {\n      var _this = this;\n\n      indent = indent || 0;\n      indent = ' '.repeat(indent);\n\n      if (!Array.isArray(stack)) {\n        stack = stack.split('\\n');\n      }\n\n      if (!/^\\s*at /.test(stack[0]) && /^\\s*at /.test(stack[1])) {\n        stack = stack.slice(1);\n      }\n\n      var outdent = false;\n      var lastNonAtLine = null;\n      var result = [];\n      stack.forEach(function (st) {\n        st = st.replace(/\\\\/g, '/');\n\n        if (_this._internals.some(function (internal) {\n          return internal.test(st);\n        })) {\n          return;\n        }\n\n        var isAtLine = /^\\s*at /.test(st);\n\n        if (outdent) {\n          st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n        } else {\n          st = st.trim();\n\n          if (isAtLine) {\n            st = st.slice(3);\n          }\n        }\n\n        st = st.replace(\"\".concat(_this._cwd, \"/\"), '');\n\n        if (st) {\n          if (isAtLine) {\n            if (lastNonAtLine) {\n              result.push(lastNonAtLine);\n              lastNonAtLine = null;\n            }\n\n            result.push(st);\n          } else {\n            outdent = true;\n            lastNonAtLine = st;\n          }\n        }\n      });\n      return result.map(function (line) {\n        return \"\".concat(indent).concat(line, \"\\n\");\n      }).join('');\n    }\n  }, {\n    key: \"captureString\",\n    value: function captureString(limit, fn) {\n      fn = fn || this.captureString;\n\n      if (typeof limit === 'function') {\n        fn = limit;\n        limit = Infinity;\n      }\n\n      var stackTraceLimit = Error.stackTraceLimit;\n\n      if (limit) {\n        Error.stackTraceLimit = limit;\n      }\n\n      var obj = {};\n      Error.captureStackTrace(obj, fn);\n      var stack = obj.stack;\n      Error.stackTraceLimit = stackTraceLimit;\n      return this.clean(stack);\n    }\n  }, {\n    key: \"capture\",\n    value: function capture(limit, fn) {\n      var _this2 = this;\n\n      fn = fn || this.capture;\n\n      if (typeof limit === 'function') {\n        fn = limit;\n        limit = Infinity;\n      }\n\n      var prepareStackTrace = Error.prepareStackTrace;\n      var stackTraceLimit = Error.stackTraceLimit;\n\n      Error.prepareStackTrace = function (obj, site) {\n        if (_this2._wrapCallSite) {\n          return site.map(_this2._wrapCallSite);\n        }\n\n        return site;\n      };\n\n      if (limit) {\n        Error.stackTraceLimit = limit;\n      }\n\n      var obj = {};\n      Error.captureStackTrace(obj, fn);\n      var stack = obj.stack;\n      Object.assign(Error, {\n        prepareStackTrace: prepareStackTrace,\n        stackTraceLimit: stackTraceLimit\n      });\n      return stack;\n    }\n  }, {\n    key: \"at\",\n    value: function at(fn) {\n      fn = fn || this.at;\n      var site = this.capture(1, fn)[0];\n\n      if (!site) {\n        return {};\n      }\n\n      var res = {\n        line: site.getLineNumber(),\n        column: site.getColumnNumber()\n      };\n      setFile(res, site.getFileName(), this._cwd);\n\n      if (site.isConstructor()) {\n        res.constructor = true;\n      }\n\n      if (site.isEval()) {\n        res.evalOrigin = site.getEvalOrigin();\n      } // Node v10 stopped with the isNative() on callsites, apparently\n\n      /* istanbul ignore next */\n\n\n      if (site.isNative()) {\n        res[\"native\"] = true;\n      }\n\n      var typename;\n\n      try {\n        typename = site.getTypeName();\n      } catch (_) {}\n\n      if (typename && typename !== 'Object' && typename !== '[object Object]') {\n        res.type = typename;\n      }\n\n      var fname = site.getFunctionName();\n\n      if (fname) {\n        res[\"function\"] = fname;\n      }\n\n      var meth = site.getMethodName();\n\n      if (meth && fname !== meth) {\n        res.method = meth;\n      }\n\n      return res;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(line) {\n      var match = line && line.match(re);\n\n      if (!match) {\n        return null;\n      }\n\n      var ctor = match[1] === 'new';\n      var fname = match[2];\n      var evalOrigin = match[3];\n      var evalFile = match[4];\n      var evalLine = Number(match[5]);\n      var evalCol = Number(match[6]);\n      var file = match[7];\n      var lnum = match[8];\n      var col = match[9];\n\n      var _native = match[10] === 'native';\n\n      var closeParen = match[11] === ')';\n      var method;\n      var res = {};\n\n      if (lnum) {\n        res.line = Number(lnum);\n      }\n\n      if (col) {\n        res.column = Number(col);\n      }\n\n      if (closeParen && file) {\n        // make sure parens are balanced\n        // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n        // that the fname should be += \" (asdf) [as foo]\" and the file\n        // should be just \"xyz.js\"\n        // walk backwards from the end to find the last unbalanced (\n        var closes = 0;\n\n        for (var i = file.length - 1; i > 0; i--) {\n          if (file.charAt(i) === ')') {\n            closes++;\n          } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n            closes--;\n\n            if (closes === -1 && file.charAt(i - 1) === ' ') {\n              var before = file.slice(0, i - 1);\n              var after = file.slice(i + 1);\n              file = after;\n              fname += \" (\".concat(before);\n              break;\n            }\n          }\n        }\n      }\n\n      if (fname) {\n        var methodMatch = fname.match(methodRe);\n\n        if (methodMatch) {\n          fname = methodMatch[1];\n          method = methodMatch[2];\n        }\n      }\n\n      setFile(res, file, this._cwd);\n\n      if (ctor) {\n        res.constructor = true;\n      }\n\n      if (evalOrigin) {\n        res.evalOrigin = evalOrigin;\n        res.evalLine = evalLine;\n        res.evalColumn = evalCol;\n        res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n      }\n\n      if (_native) {\n        res[\"native\"] = true;\n      }\n\n      if (fname) {\n        res[\"function\"] = fname;\n      }\n\n      if (method && fname !== method) {\n        res.method = method;\n      }\n\n      return res;\n    }\n  }], [{\n    key: \"nodeInternals\",\n    value: function nodeInternals() {\n      return natives.slice();\n    }\n  }]);\n\n  return StackUtils;\n}();\n\nfunction setFile(result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n\n    if (filename.startsWith(\"\".concat(cwd, \"/\"))) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  var packages = ignoredPackages.map(function (mod) {\n    return escapeStringRegexp(mod);\n  });\n  return new RegExp(\"[/\\\\\\\\]node_modules[/\\\\\\\\](?:\".concat(packages.join('|'), \")[/\\\\\\\\][^:]+:\\\\d+:\\\\d+\"));\n}\n\nvar re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy\n'(?:\\\\s*at )?' + // $1 = ctor if 'new'\n'(?:(new) )?' + // $2 = function name (can be literally anything)\n// May contain method at the end as [as xyz]\n'(?:(.*?) \\\\()?' + // (eval at <anonymous> (file.js:1:1),\n// $3 = eval origin\n// $4:$5:$6 are eval file/line/col, but not normally reported\n'(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' + // file:line:col\n// $7:$8:$9\n// $10 = 'native' if native\n'(?:(.+?):(\\\\d+):(\\\\d+)|(native))' + // maybe close the paren, then end\n// if $11 is ), then we only allow balanced parens in the filename\n// any imbalance is placed on the fname.  This is a heuristic, and\n// bound to be incorrect in some edge cases.  The bet is that\n// having weird characters in method names is more common than\n// having weird characters in filenames, which seems reasonable.\n'(\\\\)?)$');\nvar methodRe = /^(.*?) \\[as (.*?)\\]$/;\nmodule.exports = StackUtils;","map":null,"metadata":{},"sourceType":"script"}