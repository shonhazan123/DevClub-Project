{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\shonh\\\\Desktop\\\\VisualCode\\\\WebDevClub\\\\RecruitmentDay\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\shonh\\\\Desktop\\\\VisualCode\\\\WebDevClub\\\\RecruitmentDay\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\shonh\\\\Desktop\\\\VisualCode\\\\WebDevClub\\\\RecruitmentDay\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nfunction _jestMessageUtil() {\n  var data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar MS_IN_A_YEAR = 31536000000; // TODO: Copied from `jest-util` to avoid cyclic dependency. Import from `jest-util` in the next major\n\nvar setGlobal = function setGlobal(globalToMutate, key, value) {\n  // @ts-ignore: no index\n  globalToMutate[key] = value;\n};\n\nvar FakeTimers = /*#__PURE__*/function () {\n  function FakeTimers(_ref) {\n    var global = _ref.global,\n        moduleMocker = _ref.moduleMocker,\n        timerConfig = _ref.timerConfig,\n        config = _ref.config,\n        maxLoops = _ref.maxLoops;\n\n    _classCallCheck(this, FakeTimers);\n\n    _defineProperty(this, '_cancelledImmediates', void 0);\n\n    _defineProperty(this, '_cancelledTicks', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_disposed', void 0);\n\n    _defineProperty(this, '_fakeTimerAPIs', void 0);\n\n    _defineProperty(this, '_global', void 0);\n\n    _defineProperty(this, '_immediates', void 0);\n\n    _defineProperty(this, '_maxLoops', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_now', void 0);\n\n    _defineProperty(this, '_ticks', void 0);\n\n    _defineProperty(this, '_timerAPIs', void 0);\n\n    _defineProperty(this, '_timers', void 0);\n\n    _defineProperty(this, '_uuidCounter', void 0);\n\n    _defineProperty(this, '_timerConfig', void 0);\n\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference\n\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n\n    this._createMocks();\n  }\n\n  _createClass(FakeTimers, [{\n    key: \"clearAllTimers\",\n    value: function clearAllTimers() {\n      var _this = this;\n\n      this._immediates.forEach(function (immediate) {\n        return _this._fakeClearImmediate(immediate.uuid);\n      });\n\n      this._timers.clear();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._disposed = true;\n      this.clearAllTimers();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._cancelledTicks = {};\n      this._cancelledImmediates = {};\n      this._now = 0;\n      this._ticks = [];\n      this._immediates = [];\n      this._timers = new Map();\n    }\n  }, {\n    key: \"runAllTicks\",\n    value: function runAllTicks() {\n      this._checkFakeTimers(); // Only run a generous number of ticks and then bail.\n      // This is just to help avoid recursive loops\n\n\n      var i;\n\n      for (i = 0; i < this._maxLoops; i++) {\n        var tick = this._ticks.shift();\n\n        if (tick === undefined) {\n          break;\n        }\n\n        if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n          // Callback may throw, so update the map prior calling.\n          this._cancelledTicks[tick.uuid] = true;\n          tick.callback();\n        }\n      }\n\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' ticks, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"runAllImmediates\",\n    value: function runAllImmediates() {\n      this._checkFakeTimers(); // Only run a generous number of immediates and then bail.\n\n\n      var i;\n\n      for (i = 0; i < this._maxLoops; i++) {\n        var immediate = this._immediates.shift();\n\n        if (immediate === undefined) {\n          break;\n        }\n\n        this._runImmediate(immediate);\n      }\n\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' immediates, and there are still more! Assuming ' + \"we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"_runImmediate\",\n    value: function _runImmediate(immediate) {\n      if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledImmediates[immediate.uuid] = true;\n        immediate.callback();\n      }\n    }\n  }, {\n    key: \"runAllTimers\",\n    value: function runAllTimers() {\n      this._checkFakeTimers();\n\n      this.runAllTicks();\n      this.runAllImmediates(); // Only run a generous number of timers and then bail.\n      // This is just to help avoid recursive loops\n\n      var i;\n\n      for (i = 0; i < this._maxLoops; i++) {\n        var nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n        if (nextTimerHandle === null) {\n          break;\n        }\n\n        this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued\n        // during the previous handling of the timers, we should\n        // run them as well.\n\n\n        if (this._immediates.length) {\n          this.runAllImmediates();\n        }\n\n        if (this._ticks.length) {\n          this.runAllTicks();\n        }\n      }\n\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"runOnlyPendingTimers\",\n    value: function runOnlyPendingTimers() {\n      var _this2 = this;\n\n      // We need to hold the current shape of `this._timers` because existing\n      // timers can add new ones to the map and hence would run more than necessary.\n      // See https://github.com/facebook/jest/pull/4608 for details\n      var timerEntries = Array.from(this._timers.entries());\n\n      this._checkFakeTimers();\n\n      this._immediates.forEach(this._runImmediate, this);\n\n      timerEntries.sort(function (_ref2, _ref3) {\n        var _ref4 = _slicedToArray(_ref2, 2),\n            left = _ref4[1];\n\n        var _ref5 = _slicedToArray(_ref3, 2),\n            right = _ref5[1];\n\n        return left.expiry - right.expiry;\n      }).forEach(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 1),\n            timerHandle = _ref7[0];\n\n        return _this2._runTimerHandle(timerHandle);\n      });\n    }\n  }, {\n    key: \"advanceTimersToNextTimer\",\n    value: function advanceTimersToNextTimer() {\n      var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      if (steps < 1) {\n        return;\n      }\n\n      var nextExpiry = Array.from(this._timers.values()).reduce(function (minExpiry, timer) {\n        if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n        return minExpiry;\n      }, null);\n\n      if (nextExpiry !== null) {\n        this.advanceTimersByTime(nextExpiry - this._now);\n        this.advanceTimersToNextTimer(steps - 1);\n      }\n    }\n  }, {\n    key: \"advanceTimersByTime\",\n    value: function advanceTimersByTime(msToRun) {\n      this._checkFakeTimers(); // Only run a generous number of timers and then bail.\n      // This is just to help avoid recursive loops\n\n\n      var i;\n\n      for (i = 0; i < this._maxLoops; i++) {\n        var timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n        if (timerHandle === null) {\n          break;\n        }\n\n        var timerValue = this._timers.get(timerHandle);\n\n        if (timerValue === undefined) {\n          break;\n        }\n\n        var nextTimerExpiry = timerValue.expiry;\n\n        if (this._now + msToRun < nextTimerExpiry) {\n          // There are no timers between now and the target we're running to, so\n          // adjust our time cursor and quit\n          this._now += msToRun;\n          break;\n        } else {\n          msToRun -= nextTimerExpiry - this._now;\n          this._now = nextTimerExpiry;\n\n          this._runTimerHandle(timerHandle);\n        }\n      }\n\n      if (i === this._maxLoops) {\n        throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n      }\n    }\n  }, {\n    key: \"runWithRealTimers\",\n    value: function runWithRealTimers(cb) {\n      var prevClearImmediate = this._global.clearImmediate;\n      var prevClearInterval = this._global.clearInterval;\n      var prevClearTimeout = this._global.clearTimeout;\n      var prevNextTick = this._global.process.nextTick;\n      var prevSetImmediate = this._global.setImmediate;\n      var prevSetInterval = this._global.setInterval;\n      var prevSetTimeout = this._global.setTimeout;\n      this.useRealTimers();\n      var cbErr = null;\n      var errThrown = false;\n\n      try {\n        cb();\n      } catch (e) {\n        errThrown = true;\n        cbErr = e;\n      }\n\n      this._global.clearImmediate = prevClearImmediate;\n      this._global.clearInterval = prevClearInterval;\n      this._global.clearTimeout = prevClearTimeout;\n      this._global.process.nextTick = prevNextTick;\n      this._global.setImmediate = prevSetImmediate;\n      this._global.setInterval = prevSetInterval;\n      this._global.setTimeout = prevSetTimeout;\n\n      if (errThrown) {\n        throw cbErr;\n      }\n    }\n  }, {\n    key: \"useRealTimers\",\n    value: function useRealTimers() {\n      var global = this._global;\n      setGlobal(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n      setGlobal(global, 'clearInterval', this._timerAPIs.clearInterval);\n      setGlobal(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n      setGlobal(global, 'setImmediate', this._timerAPIs.setImmediate);\n      setGlobal(global, 'setInterval', this._timerAPIs.setInterval);\n      setGlobal(global, 'setTimeout', this._timerAPIs.setTimeout);\n      global.process.nextTick = this._timerAPIs.nextTick;\n    }\n  }, {\n    key: \"useFakeTimers\",\n    value: function useFakeTimers() {\n      this._createMocks();\n\n      var global = this._global;\n      setGlobal(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n      setGlobal(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n      setGlobal(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n      setGlobal(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n      setGlobal(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n      setGlobal(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n      global.process.nextTick = this._fakeTimerAPIs.nextTick;\n    }\n  }, {\n    key: \"getTimerCount\",\n    value: function getTimerCount() {\n      this._checkFakeTimers();\n\n      return this._timers.size + this._immediates.length + this._ticks.length;\n    }\n  }, {\n    key: \"_checkFakeTimers\",\n    value: function _checkFakeTimers() {\n      if (this._global.setTimeout !== this._fakeTimerAPIs.setTimeout) {\n        this._global.console.warn(\"A function to advance timers was called but the timers API is not \" + \"mocked with fake timers. Call `jest.useFakeTimers()` in this \" + \"test or enable fake timers globally by setting \" + \"`\\\"timers\\\": \\\"fake\\\"` in \" + \"the configuration file. This warning is likely a result of a \" + \"default configuration change in Jest 15.\\n\\n\" + \"Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n\" + \"Stack Trace:\\n\" + (0, _jestMessageUtil().formatStackTrace)(new Error().stack, this._config, {\n          noStackTrace: false\n        }));\n      }\n    }\n  }, {\n    key: \"_createMocks\",\n    value: function _createMocks() {\n      var _this3 = this;\n\n      var fn = function fn(impl // @ts-ignore TODO: figure out better typings here\n      ) {\n        return _this3._moduleMocker.fn().mockImplementation(impl);\n      }; // TODO: add better typings; these are mocks, but typed as regular timers\n\n\n      this._fakeTimerAPIs = {\n        clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n        clearInterval: fn(this._fakeClearTimer.bind(this)),\n        clearTimeout: fn(this._fakeClearTimer.bind(this)),\n        nextTick: fn(this._fakeNextTick.bind(this)),\n        setImmediate: fn(this._fakeSetImmediate.bind(this)),\n        setInterval: fn(this._fakeSetInterval.bind(this)),\n        setTimeout: fn(this._fakeSetTimeout.bind(this))\n      };\n    }\n  }, {\n    key: \"_fakeClearTimer\",\n    value: function _fakeClearTimer(timerRef) {\n      var uuid = this._timerConfig.refToId(timerRef);\n\n      if (uuid) {\n        this._timers[\"delete\"](String(uuid));\n      }\n    }\n  }, {\n    key: \"_fakeClearImmediate\",\n    value: function _fakeClearImmediate(uuid) {\n      this._cancelledImmediates[uuid] = true;\n    }\n  }, {\n    key: \"_fakeNextTick\",\n    value: function _fakeNextTick(callback) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (this._disposed) {\n        return;\n      }\n\n      var uuid = String(this._uuidCounter++);\n\n      this._ticks.push({\n        callback: function (_callback) {\n          function callback() {\n            return _callback.apply(this, arguments);\n          }\n\n          callback.toString = function () {\n            return _callback.toString();\n          };\n\n          return callback;\n        }(function () {\n          return callback.apply(null, args);\n        }),\n        uuid: uuid\n      });\n\n      var cancelledTicks = this._cancelledTicks;\n\n      this._timerAPIs.nextTick(function () {\n        if (!cancelledTicks.hasOwnProperty(uuid)) {\n          // Callback may throw, so update the map prior calling.\n          cancelledTicks[uuid] = true;\n          callback.apply(null, args);\n        }\n      });\n    }\n  }, {\n    key: \"_fakeSetImmediate\",\n    value: function _fakeSetImmediate(callback) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      if (this._disposed) {\n        return null;\n      }\n\n      var uuid = this._uuidCounter++;\n\n      this._immediates.push({\n        callback: function (_callback2) {\n          function callback() {\n            return _callback2.apply(this, arguments);\n          }\n\n          callback.toString = function () {\n            return _callback2.toString();\n          };\n\n          return callback;\n        }(function () {\n          return callback.apply(null, args);\n        }),\n        uuid: String(uuid)\n      });\n\n      var cancelledImmediates = this._cancelledImmediates;\n\n      this._timerAPIs.setImmediate(function () {\n        if (!cancelledImmediates.hasOwnProperty(uuid)) {\n          // Callback may throw, so update the map prior calling.\n          cancelledImmediates[String(uuid)] = true;\n          callback.apply(null, args);\n        }\n      });\n\n      return uuid;\n    }\n  }, {\n    key: \"_fakeSetInterval\",\n    value: function _fakeSetInterval(callback, intervalDelay) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      if (this._disposed) {\n        return null;\n      }\n\n      if (intervalDelay == null) {\n        intervalDelay = 0;\n      }\n\n      var uuid = this._uuidCounter++;\n\n      this._timers.set(String(uuid), {\n        callback: function (_callback3) {\n          function callback() {\n            return _callback3.apply(this, arguments);\n          }\n\n          callback.toString = function () {\n            return _callback3.toString();\n          };\n\n          return callback;\n        }(function () {\n          return callback.apply(null, args);\n        }),\n        expiry: this._now + intervalDelay,\n        interval: intervalDelay,\n        type: 'interval'\n      });\n\n      return this._timerConfig.idToRef(uuid);\n    }\n  }, {\n    key: \"_fakeSetTimeout\",\n    value: function _fakeSetTimeout(callback, delay) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      if (this._disposed) {\n        return null;\n      } // eslint-disable-next-line no-bitwise\n\n\n      delay = Number(delay) | 0;\n      var uuid = this._uuidCounter++;\n\n      this._timers.set(String(uuid), {\n        callback: function (_callback4) {\n          function callback() {\n            return _callback4.apply(this, arguments);\n          }\n\n          callback.toString = function () {\n            return _callback4.toString();\n          };\n\n          return callback;\n        }(function () {\n          return callback.apply(null, args);\n        }),\n        expiry: this._now + delay,\n        interval: undefined,\n        type: 'timeout'\n      });\n\n      return this._timerConfig.idToRef(uuid);\n    }\n  }, {\n    key: \"_getNextTimerHandle\",\n    value: function _getNextTimerHandle() {\n      var nextTimerHandle = null;\n      var soonestTime = MS_IN_A_YEAR;\n\n      this._timers.forEach(function (timer, uuid) {\n        if (timer.expiry < soonestTime) {\n          soonestTime = timer.expiry;\n          nextTimerHandle = uuid;\n        }\n      });\n\n      return nextTimerHandle;\n    }\n  }, {\n    key: \"_runTimerHandle\",\n    value: function _runTimerHandle(timerHandle) {\n      var timer = this._timers.get(timerHandle);\n\n      if (!timer) {\n        return;\n      }\n\n      switch (timer.type) {\n        case 'timeout':\n          var callback = timer.callback;\n\n          this._timers[\"delete\"](timerHandle);\n\n          callback();\n          break;\n\n        case 'interval':\n          timer.expiry = this._now + (timer.interval || 0);\n          timer.callback();\n          break;\n\n        default:\n          throw new Error('Unexpected timer type: ' + timer.type);\n      }\n    }\n  }]);\n\n  return FakeTimers;\n}();\n\nexports[\"default\"] = FakeTimers;","map":null,"metadata":{},"sourceType":"script"}